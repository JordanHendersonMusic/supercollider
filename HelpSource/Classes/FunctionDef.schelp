class::FunctionDef
summary:: FunctionDefs contain code which can be executed from a Function.
categories::Core>Kernel
related::Classes/Function

description::

subsection:: Related Keywords

method:: thisFunctionDef
The global pseudo-variable code::thisFunctionDef:: always evaluates to the
current enclosing FunctionDef.

See also: link::Classes/Function#.thisFunction#thisFunction::

instanceMethods::

subsection::Accessing

Even though it is possible to change the values in the various arrays that define the FunctionDef,
you should not do it, unless you like to crash.

method::code

Get the byte code array.

code::
{ |a = 9, b = 10, c| a + b }.def.code;
::

method::sourceCode

Get the source code as a link::Classes/String::.
code::
{ |a = 9, b = 10, c| a + b }.def.sourceCode.postcs;
::

method::context

Get the enclosing FunctionDef or Method.

method::findReferences

return a list of all references to a given symbol.

method::argNames

Get all of the arguments' names as a link::Classes/SymbolArray::.

code::
{ |a = 9, b = 10, c| a + b }.def.argNames;
::

method::argumentNamesForCall
Same as link::#-argName::, but guarantees only the argument names the user sees are present.
See link::Classes/Method#-argumentNamesForCall::.

method::prototypeFrame

Get an array of default values for all arguments and variables.

code::
{ |a = 9, b = 10, c| a + b }.def.prototypeFrame;
{ |a = 9, b = 10, c| var i = 'I\'m stored here too!'; a + b }.def.prototypeFrame;

::

method::defaultArgs
Returns the default arguments needed to call the function.


method::varNames

Get the Array of Symbols of the local variable names.

code::
{ |a = 9, b = 10, c| var x = 9; a + b + x }.def.varNames;
::
method::argumentString

Return a string that contains all argument names and their default values for embedding in a string.
If there are no arguments, it returns nil.

code::
{ |a = 9, b = 10, c| a + b }.def.argumentString; // "a = 9, b = 10, c"
{ "nothing to see here" }.def.argumentString; // nil
::

argument::withDefaultValues
If set to false, no default values are appended

code::
 // "a, b, c"
{ |a = 9, b = 10, c| a + b }.def.argumentString(withDefaultValues: false);
::

argument::withEllipsis
If set to true, ellipsis characters (code::" ... "::) are appended

code::
// "a = 9, b = 10 ... c"
{ |a = 9, b = 10 ... c| a + b }.def.argumentString(withEllipsis: true);
// "a = 9, b = 10, c"
{ |a = 9, b = 10 ... c| a + b }.def.argumentString(withEllipsis: false);
::

argument::asArray
If set to true, return the string for an array that represents all arguments. The other arguments are set to false.

code::
// "[a, b] ++ c"
{ |a = 9, b = 10 ... c| a + b }.def.argumentString(asArray: true);
::



method::makeEnvirFromArgs

Get the Array of Symbols of the local variable names.

code::
{ |a = 9, b = 10, c| a + b }.def.makeEnvirFromArgs;
::

method::makePerformableArray
Returns an array that can be passed to link::Classes/Object#-perform:: or link::Classes/Function#-value::.

Both keyword and non-keyword arguments may be supplied at the same time.
If a value for an argument is provided in both the keyword and non-keyword arguments this will throw an error.
If a keyword argument is provide, but the name can't be found an error will be thrown.

Variable arguments are best placed with a keyword argument.
If all the non-keyword arguments are present
(and the keywords empty),
then any remaining arguments will be passed to the function's variable argument if present,
if not, it will throw.

This method can be useful when implementing link::Classes/Object#-doesNotUnderstand:: and link::Classes/Object#-doesNotUnderstandWithKeys::,
as it is the easiest way to call something with a mixture of arguments and keyword arguments.

argument::argumentsArray
Arguments as an array.

argument::keywordArgumentEnvir
Keyword arguments in an link::Classes/IdentityDictionary::.

returns::Arguments as an array.
Variable arguments are appended onto the end of the array.

code::

f = { |a b ...e|
   var i = 0;
   a.debug(\a);
   b.debug(\b);
   e.debug(\e);
};

f.value(
	*f.def.makePerformableArray([\a], (e: [1,2,3]))
);

::
Better in this case to use link::Classes/Function#-valueWith:: directly as it calls this internally.
code::
f.valueWith([\a], (e: [1,2,3]));
::

subsection::Generating Strings

method::makeFuncModifierString

Return a string that can be interpreted as code for a new function which extracts the arguments from the receiver. This can be used to build a hygienic macro which returns a function with valid keyword arguments, instead of just anonymously forwarding the arguments, like in code::{ |...args| func.valueArray(args) }::.

For an implementation example link::Classes/Function#flop:: (as below).


argument::modifier
A function to which a string is passed that represents the array of all arguments. It should return a string that can be interpreted.

code::
// basic usage
f = { |x, y| x.squared + y.squared }; // a function
a = f.def.makeFuncModifierString({ |argString| "%.scramble".format(argString) });
a.interpret.value(4, 5)

// use as a macro: multichannel expansion like in flop
f = { |x, y = 1| if(x > 0) { 1 } { 0 } * y }; // some function
// generate the body of a function that has a free and yet undefined variable "func"
// -> "{ arg x, y = 1; ([x, y]).flop.collect { |x| func.valueArray(x) } }"
a = f.def.makeFuncModifierString({ |str| str ++ ".flop.collect { |x| func.valueArray(x) }" });
// wrap that body into a function that takes "func" as argument and returns the function above
// now we have a valid code for a function:
// -> "{ |func| { arg x, y = 1; [x, y].flop.collect { |x| func.valueArray(x) } } }"
b = "{ |func| % }".format(a);
// interpret the code to a function
g = b.interpret;
// pass the function f to g, which returns a function from a where "func" is bound to f
h = g.value(f);
// we can now use h in place of f, but all arguments are multichannel expanded:
f.([1, 0], [6, 7]); // does not work
h.([1, 0], [6, 7]); // [6, 0]
// and the new function supports the same keywords arguments:
h.(x:(-2..2), y:(-2..2));

// this functionality is implemented for function in the method "flop"
h = f.flop;
h.([1, 0], [6, 7]); // [6, 0]
::


subsection::Utilities

method::dumpByteCodes

"Disassemble" and post the FunctionDef's byte code instructions to the text window.
